package api

import (
	"go.uber.org/fx"
)

// Module регистрирует зависимости для API
var Module = fx.Module("api",
	fx.Provide(
		NewRouter,
	),
)
package api
package api

import (
	"net/http"

	"go.uber.org/zap"

	"github.com/gorilla/mux"
	httpSwagger "github.com/swaggo/http-swagger"

	"scrapper/internal/handlers"
)

// NewRouter создает и настраивает маршрутизатор
func NewRouter(
	logger *zap.Logger,
	parserHandler handlers.ParserHandler,
	downloaderHandler handlers.DownloaderHandler,
	crawlerHandler handlers.CrawlerHandler,
) *mux.Router {
	router := mux.NewRouter()

	// API маршруты
	apiRouter := router.PathPrefix("/api/v1").Subrouter()

	// Регистрируем маршруты парсера
	apiRouter.HandleFunc("/parse", parserHandler.ParseURL).Methods(http.MethodPost)
	apiRouter.HandleFunc("/operations/{id}", parserHandler.GetOperationResult).Methods(http.MethodGet)
	apiRouter.HandleFunc("/operations/{id}/export", parserHandler.ExportOperation).Methods(http.MethodGet)

	// Регистрируем маршруты загрузчика
	apiRouter.HandleFunc("/download/{id}", downloaderHandler.DownloadByID).Methods(http.MethodGet)
	apiRouter.HandleFunc("/formats", downloaderHandler.GetFormats).Methods(http.MethodGet)

	// Регистрируем маршруты краулера
	apiRouter.HandleFunc("/crawl", crawlerHandler.CrawlURL).Methods(http.MethodPost)

	// Swagger UI
	router.PathPrefix("/swagger/").Handler(httpSwagger.WrapHandler)

	return router
}
package main

import (
	"go.uber.org/fx"

	"go.uber.org/zap"

	"scrapper/api/v1"
	"scrapper/config"
	"scrapper/internal/app"
	"scrapper/internal/handlers"
	"scrapper/internal/repos"
	"scrapper/internal/services"
)

func main() {
	logger, _ := zap.NewProduction()
	defer logger.Sync()

	application := fx.New(
		fx.Supply(logger),
		fx.Provide(
			config.NewConfig,
		),
		repos.Module,
		services.Module,
		handlers.Module,
		api.Module,
		app.Module,
	)

	application.Run()
}
package config

import (
	"os"
	"strconv"
	"time"
)

type Config struct {
	Server   ServerConfig
	Database DatabaseConfig
	Scraper  ScraperConfig
}

type ServerConfig struct {
	Port         string
	ReadTimeout  time.Duration
	WriteTimeout time.Duration
}

type DatabaseConfig struct {
	Host     string
	Port     string
	Username string
	Password string
	DBName   string
	SSLMode  string
}

type ScraperConfig struct {
	UserAgent      string
	Timeout        time.Duration
	MaxDepth       int
	AllowedDomains []string
}

func getEnv(key, defaultValue string) string {
	if value, exists := os.LookupEnv(key); exists {
		return value
	}
	return defaultValue
}

func getEnvInt(key string, defaultValue int) int {
	if value, exists := os.LookupEnv(key); exists {
		intValue, err := strconv.Atoi(value)
		if err == nil {
			return intValue
		}
	}
	return defaultValue
}

func getEnvDuration(key string, defaultValue time.Duration) time.Duration {
	if value, exists := os.LookupEnv(key); exists {
		duration, err := time.ParseDuration(value)
		if err == nil {
			return duration
		}
	}
	return defaultValue
}

func NewConfig() *Config {
	return &Config{
		Server: ServerConfig{
			Port:         getEnv("SERVER_PORT", "8080"),
			ReadTimeout:  getEnvDuration("SERVER_READ_TIMEOUT", 5*time.Second),
			WriteTimeout: getEnvDuration("SERVER_WRITE_TIMEOUT", 10*time.Second),
		},
		Database: DatabaseConfig{
			Host:     getEnv("DB_HOST", "postgres"),
			Port:     getEnv("DB_PORT", "5432"),
			Username: getEnv("DB_USER", "postgres"),
			Password: getEnv("DB_PASSWORD", "postgres"),
			DBName:   getEnv("DB_NAME", "scraper"),
			SSLMode:  getEnv("DB_SSLMODE", "disable"),
		},
		Scraper: ScraperConfig{
			UserAgent: getEnv("SCRAPER_USER_AGENT", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36"),
			Timeout:   getEnvDuration("SCRAPER_TIMEOUT", 30*time.Second),
			MaxDepth:  getEnvInt("SCRAPER_MAX_DEPTH", 2),
			AllowedDomains: []string{
				"botcreators.ru",
				"structura.app",
				"automatisation.art",
				"mindbox.ru",
				"skillfactory.ru",
			},
		},
	}
}

// GetPostgresDSN возвращает строку подключения к PostgreSQL
func (c *DatabaseConfig) GetPostgresDSN() string {
	return "postgres://" + c.Username + ":" + c.Password + "@" + c.Host + ":" + c.Port + "/" + c.DBName + "?sslmode=" + c.SSLMode
}
package app

import (
	"context"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/gorilla/mux"
	"go.uber.org/fx"
	"go.uber.org/zap"

	"scrapper/config"
)

// Module регистрирует зависимости для приложения
var Module = fx.Module("app",
	fx.Invoke(
		StartServer,
	),
)

// StartServer запускает HTTP-сервер
func StartServer(lifecycle fx.Lifecycle, router *mux.Router, cfg *config.Config, logger *zap.Logger) {
	server := &http.Server{
		Addr:         ":" + cfg.Server.Port,
		Handler:      router,
		ReadTimeout:  cfg.Server.ReadTimeout,
		WriteTimeout: cfg.Server.WriteTimeout,
	}

	lifecycle.Append(fx.Hook{
		OnStart: func(ctx context.Context) error {
			go func() {
				logger.Info("Starting HTTP server", zap.String("port", cfg.Server.Port))
				if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
					logger.Fatal("Failed to start server", zap.Error(err))
				}
			}()

			// Обработка сигналов для грациозного завершения
			go func() {
				sigChan := make(chan os.Signal, 1)
				signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
				sig := <-sigChan
				logger.Info("Received signal", zap.String("signal", sig.String()))

				// Создаем контекст с таймаутом для завершения
				shutdownCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
				defer cancel()

				if err := server.Shutdown(shutdownCtx); err != nil {
					logger.Error("Server shutdown error", zap.Error(err))
				}

				logger.Info("Server gracefully stopped")
			}()

			return nil
		},
		OnStop: func(ctx context.Context) error {
			logger.Info("Stopping HTTP server")
			return server.Shutdown(ctx)
		},
	})
}
package dto

import (
	"time"

	"github.com/google/uuid"
)

// OperationStatus представляет статус операции парсинга
type OperationStatus string

const (
	StatusPending    OperationStatus = "pending"
	StatusProcessing OperationStatus = "processing"
	StatusCompleted  OperationStatus = "completed"
	StatusError      OperationStatus = "error"
)

// BlockType представляет тип блока
type BlockType string

const (
	BlockTypeHeader BlockType = "header"
	BlockTypeFooter BlockType = "footer"
)

// Platform представляет платформу сайта
type Platform string

const (
	PlatformWordPress Platform = "wordpress"
	PlatformTilda     Platform = "tilda"
	PlatformBitrix    Platform = "bitrix"
	PlatformHTML5     Platform = "html5"
	PlatformUnknown   Platform = "unknown"
)

// Operation представляет операцию парсинга
type Operation struct {
	ID        uuid.UUID       `json:"id"`
	URL       string          `json:"url"`
	Status    OperationStatus `json:"status"`
	CreatedAt time.Time       `json:"created_at"`
	UpdatedAt time.Time       `json:"updated_at"`
}

// Block представляет блок, найденный при парсинге
type Block struct {
	ID          uuid.UUID   `json:"id"`
	OperationID uuid.UUID   `json:"operation_id"`
	BlockType   BlockType   `json:"block_type"`
	Platform    Platform    `json:"platform"`
	Content     interface{} `json:"content"`
	HTML        string      `json:"html"`
	CreatedAt   time.Time   `json:"created_at"`
}

// ParseURLRequest представляет запрос на парсинг URL
type ParseURLRequest struct {
	URL string `json:"url"`
}

// ParseURLResponse представляет ответ на запрос парсинга URL
type ParseURLResponse struct {
	OperationID uuid.UUID `json:"operation_id"`
}

// GetOperationResultRequest представляет запрос на получение результатов операции
type GetOperationResultRequest struct {
	OperationID uuid.UUID `json:"operation_id"`
}

// GetOperationResultResponse представляет ответ с результатами операции
type GetOperationResultResponse struct {
	Operation Operation `json:"operation"`
	Blocks    []Block   `json:"blocks"`
}

// ExportOperationRequest представляет запрос на экспорт результатов операции
type ExportOperationRequest struct {
	OperationID uuid.UUID `json:"operation_id"`
	Format      string    `json:"format"` // "excel" или "text"
}

// ExportOperationResponse представляет ответ на запрос экспорта
type ExportOperationResponse struct {
	Filename string `json:"filename"`
	Content  []byte `json:"content"`
}

// ErrorResponse представляет ответ с ошибкой
type ErrorResponse struct {
	Error string `json:"error"`
}
package handlers

import (
	"encoding/json"
	"go.uber.org/zap"
	"net/http"

	"scrapper/internal/services"
)

// crawlerHandler реализация CrawlerHandler
type crawlerHandler struct {
	logger  *zap.Logger
	service services.CrawlerService
}

// NewCrawlerHandler создает новый экземпляр CrawlerHandler
func NewCrawlerHandler(logger *zap.Logger, service services.CrawlerService) CrawlerHandler {
	return &crawlerHandler{
		logger:  logger,
		service: service,
	}
}

// CrawlURL обрабатывает запрос на обход URL и сбор ссылок
func (h *crawlerHandler) CrawlURL(w http.ResponseWriter, r *http.Request) {
	var req struct {
		URL      string `json:"url"`
		MaxDepth int    `json:"max_depth,omitempty"`
	}

	// Декодируем тело запроса
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		h.logger.Error("Failed to decode request body", zap.Error(err))
		RespondWithError(w, http.StatusBadRequest, "Invalid request body")
		return
	}

	// Проверяем URL
	if req.URL == "" {
		RespondWithError(w, http.StatusBadRequest, "URL is required")
		return
	}

	// Устанавливаем глубину обхода
	maxDepth := 2 // По умолчанию
	if req.MaxDepth > 0 {
		maxDepth = req.MaxDepth
	}

	// Проверяем, разрешен ли домен
	if !h.service.IsAllowedDomain(req.URL) {
		RespondWithError(w, http.StatusBadRequest, "Domain not allowed")
		return
	}

	// Обходим URL
	links, err := h.service.CrawlURL(r.Context(), req.URL, maxDepth)
	if err != nil {
		h.logger.Error("Failed to crawl URL", zap.Error(err))
		RespondWithError(w, http.StatusInternalServerError, "Failed to crawl URL")
		return
	}

	// Формируем ответ
	response := struct {
		URL   string   `json:"url"`
		Links []string `json:"links"`
		Count int      `json:"count"`
	}{
		URL:   req.URL,
		Links: links,
		Count: len(links),
	}

	RespondWithJSON(w, http.StatusOK, response)
}
package handlers

import (
	"go.uber.org/zap"
	"net/http"
	"scrapper/internal/services"
)

// downloaderHandler реализация DownloaderHandler
type downloaderHandler struct {
	logger  *zap.Logger
	service services.DownloaderService
}

// NewDownloaderHandler создает новый экземпляр DownloaderHandler
func NewDownloaderHandler(logger *zap.Logger, service services.DownloaderService) DownloaderHandler {
	return &downloaderHandler{
		logger:  logger,
		service: service,
	}
}

// DownloadByID обрабатывает запрос на загрузку файлов по ID операции
func (h *downloaderHandler) DownloadByID(w http.ResponseWriter, r *http.Request) {
	panic("implement me")
}

// GetFormats обрабатывает запрос на получение доступных форматов
func (h *downloaderHandler) GetFormats(w http.ResponseWriter, r *http.Request) {
	formats := h.service.GetAvailableFormats()

	response := struct {
		Formats []string `json:"formats"`
	}{
		Formats: formats,
	}

	RespondWithJSON(w, http.StatusOK, response)
}
package handlers

import (
	"net/http"
)

// ParserHandler представляет интерфейс для обработчика парсера
type ParserHandler interface {
	// ParseURL обрабатывает запрос на парсинг URL
	ParseURL(w http.ResponseWriter, r *http.Request)

	// GetOperationResult обрабатывает запрос на получение результатов операции
	GetOperationResult(w http.ResponseWriter, r *http.Request)

	// ExportOperation обрабатывает запрос на экспорт результатов операции
	ExportOperation(w http.ResponseWriter, r *http.Request)
}

// DownloaderHandler представляет интерфейс для обработчика загрузчика
type DownloaderHandler interface {
	// DownloadByID обрабатывает запрос на загрузку файлов по ID операции
	DownloadByID(w http.ResponseWriter, r *http.Request)

	// GetFormats обрабатывает запрос на получение доступных форматов
	GetFormats(w http.ResponseWriter, r *http.Request)
}

// CrawlerHandler представляет интерфейс для обработчика краулера
type CrawlerHandler interface {
	// CrawlURL обрабатывает запрос на обход URL и сбор ссылок
	CrawlURL(w http.ResponseWriter, r *http.Request)
}
package handlers

import (
	"go.uber.org/fx"
)

// Module регистрирует зависимости для обработчиков
var Module = fx.Module("handlers",
	fx.Provide(
		NewParserHandler,
		NewDownloaderHandler,
		NewCrawlerHandler,
	),
)
package handlers

import (
	"encoding/json"
	"net/http"

	"github.com/google/uuid"
	"github.com/gorilla/mux"
	"go.uber.org/zap"

	"scrapper/internal/dto"
	"scrapper/internal/services"
)

// parserHandler реализация ParserHandler
type parserHandler struct {
	logger  *zap.Logger
	service services.ParserService
}

// NewParserHandler создает новый экземпляр ParserHandler
func NewParserHandler(logger *zap.Logger, service services.ParserService) ParserHandler {
	return &parserHandler{
		logger:  logger,
		service: service,
	}
}

// ParseURL обрабатывает запрос на парсинг URL
func (h *parserHandler) ParseURL(w http.ResponseWriter, r *http.Request) {
	var req dto.ParseURLRequest

	// Декодируем тело запроса
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		h.logger.Error("Failed to decode request body", zap.Error(err))
		RespondWithError(w, http.StatusBadRequest, "Invalid request body")
		return
	}

	// Проверяем URL
	if req.URL == "" {
		RespondWithError(w, http.StatusBadRequest, "URL is required")
		return
	}

	// Вызываем сервис для парсинга URL
	operationID, err := h.service.ParseURL(r.Context(), req.URL)
	if err != nil {
		h.logger.Error("Failed to parse URL", zap.Error(err))
		RespondWithError(w, http.StatusInternalServerError, "Failed to parse URL")
		return
	}

	// Формируем ответ
	response := dto.ParseURLResponse{
		OperationID: operationID,
	}

	RespondWithJSON(w, http.StatusOK, response)
}

// GetOperationResult обрабатывает запрос на получение результатов операции
func (h *parserHandler) GetOperationResult(w http.ResponseWriter, r *http.Request) {
	// Получаем ID операции из URL
	vars := mux.Vars(r)
	operationIDStr := vars["id"]

	// Проверяем ID операции
	operationID, err := uuid.Parse(operationIDStr)
	if err != nil {
		h.logger.Error("Invalid operation ID", zap.Error(err))
		RespondWithError(w, http.StatusBadRequest, "Invalid operation ID")
		return
	}

	// Вызываем сервис для получения результатов операции
	result, err := h.service.GetOperationResult(r.Context(), operationID)
	if err != nil {
		h.logger.Error("Failed to get operation result", zap.Error(err))
		RespondWithError(w, http.StatusInternalServerError, "Failed to get operation result")
		return
	}

	RespondWithJSON(w, http.StatusOK, result)
}

// ExportOperation обрабатывает запрос на экспорт результатов операции
func (h *parserHandler) ExportOperation(w http.ResponseWriter, r *http.Request) {
	// Получаем ID операции из URL
	vars := mux.Vars(r)
	operationIDStr := vars["id"]

	// Проверяем ID операции
	operationID, err := uuid.Parse(operationIDStr)
	if err != nil {
		h.logger.Error("Invalid operation ID", zap.Error(err))
		RespondWithError(w, http.StatusBadRequest, "Invalid operation ID")
		return
	}

	// Получаем формат экспорта из query параметров
	format := r.URL.Query().Get("format")
	if format == "" {
		format = "excel" // По умолчанию Excel
	}

	// Проверяем формат
	if format != "excel" && format != "text" {
		RespondWithError(w, http.StatusBadRequest, "Invalid format. Supported formats: excel, text")
		return
	}

	// Вызываем сервис для экспорта операции
	content, filename, err := h.service.ExportOperation(r.Context(), operationID, format)
	if err != nil {
		h.logger.Error("Failed to export operation", zap.Error(err))
		RespondWithError(w, http.StatusInternalServerError, "Failed to export operation")
		return
	}

	// Устанавливаем заголовки для скачивания файла
	w.Header().Set("Content-Disposition", "attachment; filename="+filename)
	w.Header().Set("Content-Type", getContentType(format))
	w.Header().Set("Content-Length", string(len(content)))

	w.WriteHeader(http.StatusOK)
	w.Write(content)
}

// getContentType возвращает Content-Type в зависимости от формата
func getContentType(format string) string {
	switch format {
	case "excel":
		return "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
	case "text":
		return "text/plain"
	default:
		return "application/octet-stream"
	}
}

// RespondWithError отправляет клиенту ошибку в формате JSON
func RespondWithError(w http.ResponseWriter, code int, message string) {
	RespondWithJSON(w, code, dto.ErrorResponse{Error: message})
}

// RespondWithJSON отправляет клиенту данные в формате JSON
func RespondWithJSON(w http.ResponseWriter, code int, payload interface{}) {
	response, _ := json.Marshal(payload)

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(code)
	w.Write(response)
}
package repos

import (
	"context"

	"scrapper/internal/dto"

	"github.com/google/uuid"
)

// ParserRepo представляет интерфейс для репозитория парсера
type ParserRepo interface {
	// CreateOperation создает новую операцию парсинга
	CreateOperation(ctx context.Context, url string) (uuid.UUID, error)

	// UpdateOperationStatus обновляет статус операции
	UpdateOperationStatus(ctx context.Context, operationID uuid.UUID, status dto.OperationStatus) error

	// GetOperationByID получает операцию по ID
	GetOperationByID(ctx context.Context, operationID uuid.UUID) (*dto.Operation, error)

	// SaveBlock сохраняет блок, найденный при парсинге
	SaveBlock(ctx context.Context, block *dto.Block) error

	// GetBlocksByOperationID получает все блоки по ID операции
	GetBlocksByOperationID(ctx context.Context, operationID uuid.UUID) ([]dto.Block, error)
}
package repos

import (
	"database/sql"
	"scrapper/config"
	"time"

	"go.uber.org/fx"
	"go.uber.org/zap"
)

// Module регистрирует зависимости для репозиториев
var Module = fx.Module("repos",
	fx.Provide(
		NewPostgresConnection,
		NewParserRepo,
	),
)

// NewPostgresConnection создает подключение к базе данных PostgreSQL
func NewPostgresConnection(cfg *config.Config, logger *zap.Logger) (*sql.DB, error) {
	db, err := sql.Open("postgres", cfg.Database.GetPostgresDSN())
	if err != nil {
		return nil, err
	}

	// Настраиваем пул соединений
	db.SetMaxOpenConns(25)
	db.SetMaxIdleConns(5)
	db.SetConnMaxLifetime(5 * time.Minute)

	// Пингуем базу для проверки соединения
	if err := db.Ping(); err != nil {
		return nil, err
	}

	logger.Info("Connected to PostgreSQL database")
	return db, nil
}
package repos
package repos

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"

	"github.com/google/uuid"
	_ "github.com/lib/pq"
	"go.uber.org/zap"

	"scrapper/internal/dto"
)

// PostgresRepo реализация ParserRepo для PostgreSQL
type PostgresRepo struct {
	db     *sql.DB
	logger *zap.Logger
}

// NewParserRepo создает новый экземпляр ParserRepo
func NewParserRepo(db *sql.DB, logger *zap.Logger) ParserRepo {
	return &PostgresRepo{
		db:     db,
		logger: logger,
	}
}

// CreateOperation создает новую операцию парсинга
func (r *PostgresRepo) CreateOperation(ctx context.Context, url string) (uuid.UUID, error) {
	var operationID uuid.UUID

	query := `
	INSERT INTO operations (url, status)
	VALUES ($1, $2)
	RETURNING id
	`

	err := r.db.QueryRowContext(ctx, query, url, dto.StatusPending).Scan(&operationID)
	if err != nil {
		return uuid.Nil, fmt.Errorf("failed to create operation: %w", err)
	}

	return operationID, nil
}

// UpdateOperationStatus обновляет статус операции
func (r *PostgresRepo) UpdateOperationStatus(ctx context.Context, operationID uuid.UUID, status dto.OperationStatus) error {
	query := `
	UPDATE operations
	SET status = $1, updated_at = NOW()
	WHERE id = $2
	`

	_, err := r.db.ExecContext(ctx, query, status, operationID)
	if err != nil {
		return fmt.Errorf("failed to update operation status: %w", err)
	}

	return nil
}

// GetOperationByID получает операцию по ID
func (r *PostgresRepo) GetOperationByID(ctx context.Context, operationID uuid.UUID) (*dto.Operation, error) {
	query := `
	SELECT id, url, status, created_at, updated_at
	FROM operations
	WHERE id = $1
	`

	var operation dto.Operation
	var status string

	err := r.db.QueryRowContext(ctx, query, operationID).Scan(
		&operation.ID,
		&operation.URL,
		&status,
		&operation.CreatedAt,
		&operation.UpdatedAt,
	)

	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("operation not found: %s", operationID)
		}
		return nil, fmt.Errorf("failed to get operation: %w", err)
	}

	operation.Status = dto.OperationStatus(status)

	return &operation, nil
}

// SaveBlock сохраняет блок, найденный при парсинге
func (r *PostgresRepo) SaveBlock(ctx context.Context, block *dto.Block) error {
	contentJSON, err := json.Marshal(block.Content)
	if err != nil {
		return fmt.Errorf("failed to marshal block content: %w", err)
	}

	query := `
	INSERT INTO blocks (operation_id, block_type, platform, content, html)
	VALUES ($1, $2, $3, $4, $5)
	RETURNING id, created_at
	`

	err = r.db.QueryRowContext(
		ctx,
		query,
		block.OperationID,
		block.BlockType,
		block.Platform,
		contentJSON,
		block.HTML,
	).Scan(&block.ID, &block.CreatedAt)

	if err != nil {
		return fmt.Errorf("failed to save block: %w", err)
	}

	return nil
}

// GetBlocksByOperationID получает все блоки по ID операции
func (r *PostgresRepo) GetBlocksByOperationID(ctx context.Context, operationID uuid.UUID) ([]dto.Block, error) {
	query := `
	SELECT id, operation_id, block_type, platform, content, html, created_at
	FROM blocks
	WHERE operation_id = $1
	ORDER BY created_at
	`

	rows, err := r.db.QueryContext(ctx, query, operationID)
	if err != nil {
		return nil, fmt.Errorf("failed to get blocks: %w", err)
	}
	defer rows.Close()

	var blocks []dto.Block

	for rows.Next() {
		var block dto.Block
		var blockType, platform string
		var contentJSON []byte

		err := rows.Scan(
			&block.ID,
			&block.OperationID,
			&blockType,
			&platform,
			&contentJSON,
			&block.HTML,
			&block.CreatedAt,
		)

		if err != nil {
			return nil, fmt.Errorf("failed to scan block: %w", err)
		}

		block.BlockType = dto.BlockType(blockType)
		block.Platform = dto.Platform(platform)

		var content map[string]interface{}
		if err := json.Unmarshal(contentJSON, &content); err != nil {
			return nil, fmt.Errorf("failed to unmarshal block content: %w", err)
		}

		block.Content = content
		blocks = append(blocks, block)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating blocks: %w", err)
	}

	return blocks, nil
}
package services

import (
	"go.uber.org/zap"

	"scrapper/internal/dto"
)

// bitrixService реализация BitrixService
type bitrixService struct {
	logger *zap.Logger
}

// NewBitrixService создает новый экземпляр BitrixService
func NewBitrixService(logger *zap.Logger) BitrixService {
	return &bitrixService{
		logger: logger,
	}
}

// DetectPlatform проверяет, соответствует ли страница Bitrix
func (s *bitrixService) DetectPlatform(html string) bool {
	panic("implement me")
}

// ParseHeader парсит шапку сайта Bitrix
func (s *bitrixService) ParseHeader(html string) (*dto.Block, error) {
	panic("implement me")
}

// ParseFooter парсит подвал сайта Bitrix
func (s *bitrixService) ParseFooter(html string) (*dto.Block, error) {
	panic("implement me")
}
package services

import (
	"context"

	"go.uber.org/zap"
)

// crawlerService реализация CrawlerService
type crawlerService struct {
	logger         *zap.Logger
	userAgent      string
	maxDepth       int
	allowedDomains []string
}

// NewCrawlerService создает новый экземпляр CrawlerService
func NewCrawlerService(logger *zap.Logger, allowedDomains []string) CrawlerService {
	return &crawlerService{
		logger:         logger,
		userAgent:      "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36",
		maxDepth:       2,
		allowedDomains: allowedDomains,
	}
}

// CrawlURL обходит URL и собирает ссылки
func (s *crawlerService) CrawlURL(ctx context.Context, url string, maxDepth int) ([]string, error) {
	panic("implement me")
}

// IsAllowedDomain проверяет, разрешен ли домен для обхода
func (s *crawlerService) IsAllowedDomain(url string) bool {
	panic("implement me")
}

// SetUserAgent устанавливает User-Agent для запросов
func (s *crawlerService) SetUserAgent(userAgent string) {
	s.userAgent = userAgent
}

// SetMaxDepth устанавливает максимальную глубину обхода
func (s *crawlerService) SetMaxDepth(depth int) {
	s.maxDepth = depth
}
package services

import (
	"context"
	"github.com/google/uuid"
	"go.uber.org/zap"
)

// downloaderService реализация DownloaderService
type downloaderService struct {
	logger        *zap.Logger
	parserService ParserService
}

// NewDownloaderService создает новый экземпляр DownloaderService
func NewDownloaderService(logger *zap.Logger, parserService ParserService) DownloaderService {
	return &downloaderService{
		logger:        logger,
		parserService: parserService,
	}
}

// DownloadByOperationID загружает файлы по ID операции и сохраняет их в указанный путь
func (s *downloaderService) DownloadByOperationID(ctx context.Context, operationID uuid.UUID, path string) error {
	panic("implement me")
}

// GetAvailableFormats возвращает список доступных форматов для загрузки
func (s *downloaderService) GetAvailableFormats() []string {
	return []string{"excel", "text"}
}

// DownloadByOperationIDWithFormat загружает файлы в указанном формате
func (s *downloaderService) DownloadByOperationIDWithFormat(ctx context.Context, operationID uuid.UUID, format string, path string) error {
	panic("implement me")
}
package services

import (
	"go.uber.org/zap"

	"scrapper/internal/dto"
)

// html5Service реализация HTML5Service
type html5Service struct {
	logger *zap.Logger
}

// NewHTML5Service создает новый экземпляр HTML5Service
func NewHTML5Service(logger *zap.Logger) HTML5Service {
	return &html5Service{
		logger: logger,
	}
}

// DetectPlatform проверяет, соответствует ли страница HTML5
func (s *html5Service) DetectPlatform(html string) bool {
	panic("implement me")
}

// ParseHeader парсит шапку сайта HTML5
func (s *html5Service) ParseHeader(html string) (*dto.Block, error) {
	panic("implement me")
}

// ParseFooter парсит подвал сайта HTML5
func (s *html5Service) ParseFooter(html string) (*dto.Block, error) {
	panic("implement me")
}
package services

import (
	"context"

	"scrapper/internal/dto"

	"github.com/google/uuid"
)

// PlatformService представляет интерфейс для сервиса конкретной платформы
type PlatformService interface {
	// DetectPlatform проверяет, соответствует ли страница данной платформе
	DetectPlatform(html string) bool

	// ParseHeader парсит шапку сайта
	ParseHeader(html string) (*dto.Block, error)

	// ParseFooter парсит подвал сайта
	ParseFooter(html string) (*dto.Block, error)
}

// ParserService представляет интерфейс для сервиса парсинга
type ParserService interface {
	// ParseURL парсит URL и сохраняет результаты в базу данных
	ParseURL(ctx context.Context, url string) (uuid.UUID, error)

	// GetOperationResult получает результаты операции по ID
	GetOperationResult(ctx context.Context, operationID uuid.UUID) (*dto.GetOperationResultResponse, error)

	// ExportOperation экспортирует результаты операции в файл
	ExportOperation(ctx context.Context, operationID uuid.UUID, format string) ([]byte, string, error)

	// DetectPlatform определяет платформу сайта по HTML
	DetectPlatform(html string) dto.Platform
}

// WordPressService представляет интерфейс для сервиса WordPress
type WordPressService interface {
	PlatformService
}

// TildaService представляет интерфейс для сервиса Tilda
type TildaService interface {
	PlatformService
}

// BitrixService представляет интерфейс для сервиса Bitrix
type BitrixService interface {
	PlatformService
}

// HTML5Service представляет интерфейс для сервиса HTML5
type HTML5Service interface {
	PlatformService
}

// DownloaderService представляет интерфейс для сервиса загрузки файлов
type DownloaderService interface {
	// DownloadByOperationID загружает файлы по ID операции и сохраняет их в указанный путь
	DownloadByOperationID(ctx context.Context, operationID uuid.UUID, path string) error

	// GetAvailableFormats возвращает список доступных форматов для загрузки
	GetAvailableFormats() []string

	// DownloadByOperationIDWithFormat загружает файлы в указанном формате
	DownloadByOperationIDWithFormat(ctx context.Context, operationID uuid.UUID, format string, path string) error
}

type CrawlerService interface {
	// CrawlURL обходит URL и собирает ссылки
	CrawlURL(ctx context.Context, url string, maxDepth int) ([]string, error)

	// IsAllowedDomain проверяет, разрешен ли домен для обхода
	IsAllowedDomain(url string) bool

	// SetUserAgent устанавливает User-Agent для запросов
	SetUserAgent(userAgent string)

	// SetMaxDepth устанавливает максимальную глубину обхода
	SetMaxDepth(depth int)
}
package services

import (
	"go.uber.org/fx"
	"scrapper/config"
)

// Module регистрирует зависимости для сервисов
var Module = fx.Module("services",
	fx.Provide(
		NewWordPressService,
		NewTildaService,
		NewBitrixService,
		NewHTML5Service,
		NewParserService,
		NewDownloaderService,
		func(cfg *config.Config) []string {
			return cfg.Scraper.AllowedDomains
		},
		NewCrawlerService,
	),
)
package services

import (
	"context"
	"fmt"
	"io/ioutil"
	"net/http"
	"time"

	"github.com/google/uuid"
	"github.com/xuri/excelize/v2"
	"go.uber.org/zap"

	"scrapper/internal/dto"
	"scrapper/internal/repos"
)

// parserService реализация ParserService
type parserService struct {
	logger           *zap.Logger
	repo             repos.ParserRepo
	wordpressService WordPressService
	tildaService     TildaService
	bitrixService    BitrixService
	html5Service     HTML5Service
}

// NewParserService создает новый экземпляр ParserService
func NewParserService(
	logger *zap.Logger,
	repo repos.ParserRepo,
	wordpressService WordPressService,
	tildaService TildaService,
	bitrixService BitrixService,
	html5Service HTML5Service,
) ParserService {
	return &parserService{
		logger:           logger,
		repo:             repo,
		wordpressService: wordpressService,
		tildaService:     tildaService,
		bitrixService:    bitrixService,
		html5Service:     html5Service,
	}
}

// ParseURL парсит URL и сохраняет результаты в базу данных
func (s *parserService) ParseURL(ctx context.Context, url string) (uuid.UUID, error) {
	// Создаем операцию в БД
	operationID, err := s.repo.CreateOperation(ctx, url)
	if err != nil {
		s.logger.Error("Failed to create operation", zap.Error(err))
		return uuid.Nil, err
	}

	// Обновляем статус операции
	err = s.repo.UpdateOperationStatus(ctx, operationID, dto.StatusProcessing)
	if err != nil {
		s.logger.Error("Failed to update operation status", zap.Error(err))
		return operationID, err
	}

	// Запускаем парсинг в отдельной горутине
	go func() {
		// Создаем новый контекст для горутины
		goCtx := context.Background()

		// Загружаем HTML-страницу
		client := &http.Client{
			Timeout: 30 * time.Second,
		}

		req, err := http.NewRequest("GET", url, nil)
		if err != nil {
			s.logger.Error("Failed to create request", zap.Error(err))
			s.repo.UpdateOperationStatus(goCtx, operationID, dto.StatusError)
			return
		}

		req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36")

		resp, err := client.Do(req)
		if err != nil {
			s.logger.Error("Failed to load page", zap.Error(err))
			s.repo.UpdateOperationStatus(goCtx, operationID, dto.StatusError)
			return
		}
		defer resp.Body.Close()

		if resp.StatusCode != http.StatusOK {
			s.logger.Error("Failed to load page", zap.Int("status_code", resp.StatusCode))
			s.repo.UpdateOperationStatus(goCtx, operationID, dto.StatusError)
			return
		}

		bodyBytes, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			s.logger.Error("Failed to read response body", zap.Error(err))
			s.repo.UpdateOperationStatus(goCtx, operationID, dto.StatusError)
			return
		}

		html := string(bodyBytes)

		// Определяем платформу сайта
		platform := s.DetectPlatform(html)

		// Парсим шапку и подвал в зависимости от платформы
		var headerBlock, footerBlock *dto.Block

		switch platform {
		case dto.PlatformWordPress:
			headerBlock, err = s.wordpressService.ParseHeader(html)
			if err != nil {
				s.logger.Error("Failed to parse WordPress header", zap.Error(err))
			}

			footerBlock, err = s.wordpressService.ParseFooter(html)
			if err != nil {
				s.logger.Error("Failed to parse WordPress footer", zap.Error(err))
			}
		case dto.PlatformTilda:
			headerBlock, err = s.tildaService.ParseHeader(html)
			if err != nil {
				s.logger.Error("Failed to parse Tilda header", zap.Error(err))
			}

			footerBlock, err = s.tildaService.ParseFooter(html)
			if err != nil {
				s.logger.Error("Failed to parse Tilda footer", zap.Error(err))
			}
		case dto.PlatformBitrix:
			headerBlock, err = s.bitrixService.ParseHeader(html)
			if err != nil {
				s.logger.Error("Failed to parse Bitrix header", zap.Error(err))
			}

			footerBlock, err = s.bitrixService.ParseFooter(html)
			if err != nil {
				s.logger.Error("Failed to parse Bitrix footer", zap.Error(err))
			}
		case dto.PlatformHTML5:
			headerBlock, err = s.html5Service.ParseHeader(html)
			if err != nil {
				s.logger.Error("Failed to parse HTML5 header", zap.Error(err))
			}

			footerBlock, err = s.html5Service.ParseFooter(html)
			if err != nil {
				s.logger.Error("Failed to parse HTML5 footer", zap.Error(err))
			}
		}

		// Сохраняем найденные блоки в БД
		if headerBlock != nil {
			headerBlock.OperationID = operationID
			err = s.repo.SaveBlock(goCtx, headerBlock)
			if err != nil {
				s.logger.Error("Failed to save header block", zap.Error(err))
			}
		}

		if footerBlock != nil {
			footerBlock.OperationID = operationID
			err = s.repo.SaveBlock(goCtx, footerBlock)
			if err != nil {
				s.logger.Error("Failed to save footer block", zap.Error(err))
			}
		}

		// Обновляем статус операции
		err = s.repo.UpdateOperationStatus(goCtx, operationID, dto.StatusCompleted)
		if err != nil {
			s.logger.Error("Failed to update operation status", zap.Error(err))
		}
	}()

	return operationID, nil
}

// GetOperationResult получает результаты операции по ID
func (s *parserService) GetOperationResult(ctx context.Context, operationID uuid.UUID) (*dto.GetOperationResultResponse, error) {
	// Получаем операцию из БД
	operation, err := s.repo.GetOperationByID(ctx, operationID)
	if err != nil {
		s.logger.Error("Failed to get operation", zap.Error(err))
		return nil, err
	}

	// Получаем блоки операции
	blocks, err := s.repo.GetBlocksByOperationID(ctx, operationID)
	if err != nil {
		s.logger.Error("Failed to get blocks", zap.Error(err))
		return nil, err
	}

	// Формируем ответ
	response := &dto.GetOperationResultResponse{
		Operation: *operation,
		Blocks:    blocks,
	}

	return response, nil
}

// ExportOperation экспортирует результаты операции в файл
func (s *parserService) ExportOperation(ctx context.Context, operationID uuid.UUID, format string) ([]byte, string, error) {
	// Получаем результаты операции
	result, err := s.GetOperationResult(ctx, operationID)
	if err != nil {
		return nil, "", err
	}

	var filename string
	var content []byte

	// В зависимости от формата экспортируем результаты
	switch format {
	case "excel":
		// Создаем Excel-файл
		f := excelize.NewFile()

		// Устанавливаем заголовки для первого листа (Информация об операции)
		f.SetCellValue("Sheet1", "A1", "ID")
		f.SetCellValue("Sheet1", "B1", "URL")
		f.SetCellValue("Sheet1", "C1", "Status")
		f.SetCellValue("Sheet1", "D1", "Created At")
		f.SetCellValue("Sheet1", "E1", "Updated At")

		// Заполняем данные операции
		f.SetCellValue("Sheet1", "A2", result.Operation.ID.String())
		f.SetCellValue("Sheet1", "B2", result.Operation.URL)
		f.SetCellValue("Sheet1", "C2", result.Operation.Status)
		f.SetCellValue("Sheet1", "D2", result.Operation.CreatedAt.Format(time.RFC3339))
		f.SetCellValue("Sheet1", "E2", result.Operation.UpdatedAt.Format(time.RFC3339))

		// Создаем новый лист для блоков
		f.NewSheet("Blocks")

		// Устанавливаем заголовки для листа блоков
		f.SetCellValue("Blocks", "A1", "ID")
		f.SetCellValue("Blocks", "B1", "Type")
		f.SetCellValue("Blocks", "C1", "Platform")
		f.SetCellValue("Blocks", "D1", "Created At")
		f.SetCellValue("Blocks", "E1", "HTML")

		// Заполняем данные блоков
		for i, block := range result.Blocks {
			row := i + 2
			f.SetCellValue("Blocks", fmt.Sprintf("A%d", row), block.ID.String())
			f.SetCellValue("Blocks", fmt.Sprintf("B%d", row), block.BlockType)
			f.SetCellValue("Blocks", fmt.Sprintf("C%d", row), block.Platform)
			f.SetCellValue("Blocks", fmt.Sprintf("D%d", row), block.CreatedAt.Format(time.RFC3339))
			f.SetCellValue("Blocks", fmt.Sprintf("E%d", row), block.HTML)
		}

		// Сохраняем Excel-файл в буфер
		buffer, err := f.WriteToBuffer()
		if err != nil {
			return nil, "", fmt.Errorf("failed to write Excel file: %w", err)
		}

		content = buffer.Bytes()
		filename = fmt.Sprintf("operation_%s.xlsx", operationID.String())

	case "text":
		// Формируем текстовый отчет
		textContent := fmt.Sprintf("Operation ID: %s\n", result.Operation.ID.String())
		textContent += fmt.Sprintf("URL: %s\n", result.Operation.URL)
		textContent += fmt.Sprintf("Status: %s\n", result.Operation.Status)
		textContent += fmt.Sprintf("Created At: %s\n", result.Operation.CreatedAt.Format(time.RFC3339))
		textContent += fmt.Sprintf("Updated At: %s\n\n", result.Operation.UpdatedAt.Format(time.RFC3339))

		textContent += "Blocks:\n"
		for _, block := range result.Blocks {
			textContent += fmt.Sprintf("  ID: %s\n", block.ID.String())
			textContent += fmt.Sprintf("  Type: %s\n", block.BlockType)
			textContent += fmt.Sprintf("  Platform: %s\n", block.Platform)
			textContent += fmt.Sprintf("  Created At: %s\n", block.CreatedAt.Format(time.RFC3339))
			textContent += fmt.Sprintf("  HTML: %s\n\n", block.HTML)
		}

		content = []byte(textContent)
		filename = fmt.Sprintf("operation_%s.txt", operationID.String())

	default:
		return nil, "", fmt.Errorf("unsupported format: %s", format)
	}

	return content, filename, nil
}

// DetectPlatform определяет платформу сайта по HTML
func (s *parserService) DetectPlatform(html string) dto.Platform {
	if s.wordpressService.DetectPlatform(html) {
		return dto.PlatformWordPress
	}

	if s.tildaService.DetectPlatform(html) {
		return dto.PlatformTilda
	}

	if s.bitrixService.DetectPlatform(html) {
		return dto.PlatformBitrix
	}

	if s.html5Service.DetectPlatform(html) {
		return dto.PlatformHTML5
	}

	return dto.PlatformUnknown
}
package services

import (
	"go.uber.org/zap"

	"scrapper/internal/dto"
)

// tildaService реализация TildaService
type tildaService struct {
	logger *zap.Logger
}

// NewTildaService создает новый экземпляр TildaService
func NewTildaService(logger *zap.Logger) TildaService {
	return &tildaService{
		logger: logger,
	}
}

// DetectPlatform проверяет, соответствует ли страница Tilda
func (s *tildaService) DetectPlatform(html string) bool {
	panic("implement me")
}

// ParseHeader парсит шапку сайта Tilda
func (s *tildaService) ParseHeader(html string) (*dto.Block, error) {
	panic("implement me")
}

// ParseFooter парсит подвал сайта Tilda
func (s *tildaService) ParseFooter(html string) (*dto.Block, error) {
	panic("implement me")
}
package services

import (
	"regexp"
	"strings"

	"go.uber.org/zap"

	"scrapper/internal/dto"
)

// wordPressService реализация WordPressService
type wordPressService struct {
	logger *zap.Logger
}

// NewWordPressService создает новый экземпляр WordPressService
func NewWordPressService(logger *zap.Logger) WordPressService {
	return &wordPressService{
		logger: logger,
	}
}

// DetectPlatform проверяет, соответствует ли страница WordPress
func (s *wordPressService) DetectPlatform(html string) bool {
	// Проверяем наличие характерных признаков WordPress
	wpPatterns := []string{
		`wp-content`,
		`wp-includes`,
		`wp-json`,
		`<meta name="generator" content="WordPress`,
		`class="wordpress"`,
	}

	for _, pattern := range wpPatterns {
		if strings.Contains(html, pattern) {
			s.logger.Debug("WordPress pattern detected", zap.String("pattern", pattern))
			return true
		}
	}

	return false
}

// ParseHeader парсит шапку сайта WordPress
func (s *wordPressService) ParseHeader(html string) (*dto.Block, error) {
	// Создаем регулярное выражение для поиска шапки
	reHeader := regexp.MustCompile(`(?s)<header.*?>(.*?)</header>`)
	headerMatch := reHeader.FindStringSubmatch(html)

	// Если не найдено <header>, пробуем найти по id или классу
	if len(headerMatch) < 2 {
		reHeaderClass := regexp.MustCompile(`(?s)<div\s+(?:class=".*?header.*?".*?|id=".*?header.*?".*?)>(.*?)</div>`)
		headerMatch = reHeaderClass.FindStringSubmatch(html)
	}

	// Если все еще не найдено, пробуем найти .site-header
	if len(headerMatch) < 2 {
		reSiteHeader := regexp.MustCompile(`(?s)<div\s+class=".*?site-header.*?".*?>(.*?)</div>`)
		headerMatch = reSiteHeader.FindStringSubmatch(html)
	}

	// Если шапка не найдена, возвращаем nil
	if len(headerMatch) < 2 {
		s.logger.Warn("WordPress header not found")
		return nil, nil
	}

	headerHtml := headerMatch[0]

	// Парсим логотип
	reLogo := regexp.MustCompile(`(?s)<a.*?class=".*?logo.*?".*?>(.*?)</a>`)
	logoMatch := reLogo.FindStringSubmatch(headerHtml)

	var logoHtml string
	if len(logoMatch) >= 2 {
		logoHtml = logoMatch[0]
	}

	// Парсим навигационное меню
	reMenu := regexp.MustCompile(`(?s)<nav.*?>(.*?)</nav>`)
	menuMatch := reMenu.FindStringSubmatch(headerHtml)

	var menuHtml string
	if len(menuMatch) >= 2 {
		menuHtml = menuMatch[0]
	}

	// Создаем структуру для хранения содержимого шапки
	content := map[string]interface{}{
		"logo": logoHtml,
		"menu": menuHtml,
	}

	// Создаем блок
	block := &dto.Block{
		BlockType: dto.BlockTypeHeader,
		Platform:  dto.PlatformWordPress,
		Content:   content,
		HTML:      headerHtml,
	}

	s.logger.Debug("WordPress header parsed successfully")
	return block, nil
}

// ParseFooter парсит подвал сайта WordPress
func (s *wordPressService) ParseFooter(html string) (*dto.Block, error) {
	// Создаем регулярное выражение для поиска подвала
	reFooter := regexp.MustCompile(`(?s)<footer.*?>(.*?)</footer>`)
	footerMatch := reFooter.FindStringSubmatch(html)

	// Если не найдено <footer>, пробуем найти по id или классу
	if len(footerMatch) < 2 {
		reFooterClass := regexp.MustCompile(`(?s)<div\s+(?:class=".*?footer.*?".*?|id=".*?footer.*?".*?)>(.*?)</div>`)
		footerMatch = reFooterClass.FindStringSubmatch(html)
	}

	// Если все еще не найдено, пробуем найти .site-footer
	if len(footerMatch) < 2 {
		reSiteFooter := regexp.MustCompile(`(?s)<div\s+class=".*?site-footer.*?".*?>(.*?)</div>`)
		footerMatch = reSiteFooter.FindStringSubmatch(html)
	}

	// Если подвал не найден, возвращаем nil
	if len(footerMatch) < 2 {
		s.logger.Warn("WordPress footer not found")
		return nil, nil
	}

	footerHtml := footerMatch[0]

	// Парсим виджеты
	reWidgets := regexp.MustCompile(`(?s)<div\s+class=".*?widgets.*?".*?>(.*?)</div>`)
	widgetsMatch := reWidgets.FindStringSubmatch(footerHtml)

	var widgetsHtml string
	if len(widgetsMatch) >= 2 {
		widgetsHtml = widgetsMatch[0]
	}

	// Парсим копирайт
	reCopyright := regexp.MustCompile(`(?s)<div\s+class=".*?copyright.*?".*?>(.*?)</div>`)
	copyrightMatch := reCopyright.FindStringSubmatch(footerHtml)

	var copyrightHtml string
	if len(copyrightMatch) >= 2 {
		copyrightHtml = copyrightMatch[0]
	}

	// Создаем структуру для хранения содержимого подвала
	content := map[string]interface{}{
		"widgets":   widgetsHtml,
		"copyright": copyrightHtml,
	}

	// Создаем блок
	block := &dto.Block{
		BlockType: dto.BlockTypeFooter,
		Platform:  dto.PlatformWordPress,
		Content:   content,
		HTML:      footerHtml,
	}

	s.logger.Debug("WordPress footer parsed successfully")
	return block, nil
}

